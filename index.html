<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Koi Pond — by Opulent Hardware</title>
<link href="https://fonts.googleapis.com/css2?family=Saira:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root {
    --bg:#000;
    --hud:#e8e8e8;
    --hudDim:#9aa0a6;
    --gridGlow:#00ff4c;
    --brand:rgba(255,255,255,0.9);
  }
  html,body{
    height:100%;width:100%;margin:0;background:var(--bg);color:var(--hud);
    font-family:"Saira",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    overscroll-behavior:none;touch-action:none;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none;
  }
  *{-webkit-tap-highlight-color:transparent}

  .stage{
    position:fixed;inset:0;
    background:
      radial-gradient(1200px 800px at 50% 50%, rgba(0,255,76,0.08), transparent 60%),
      radial-gradient(900px 600px at 50% 50%, rgba(54,168,255,0.06), transparent 60%),
      radial-gradient(100% 100% at 50% 120%, rgba(0,0,0,0.6), rgba(0,0,0,1));
  }

  canvas{position:absolute;inset:0;width:100%;height:100%;display:block;pointer-events:auto}

  .hud{
    position:absolute;left:12px;right:12px;top:10px;
    display:grid;grid-template-columns:1fr auto 1fr;
    align-items:center;gap:10px;
    text-shadow:0 0 10px rgba(0,0,0,.6);
    z-index:10;pointer-events:none;
    transition:opacity .25s, transform .25s;
  }
  .hud-left,.hud-center,.hud-right{display:flex;align-items:center;gap:10px}
  .hud-left{pointer-events:none}
  .hud-center{pointer-events:auto;justify-content:center;flex-wrap:wrap}
  .hud-right{pointer-events:none;justify-content:flex-end;white-space:nowrap;font-weight:700;opacity:.95;color:var(--brand)}

  .ctl{
    padding:8px 14px;border-radius:999px;font-weight:800;letter-spacing:.4px;cursor:pointer;
    background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);
    box-shadow:0 0 0 1px rgba(255,255,255,.04) inset,0 10px 25px rgba(0,0,0,.55);
    backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);
    touch-action:manipulation;user-select:none;color:var(--hud)
  }
  .ctl:active{transform:scale(.98)}

  .hint{
    position:absolute;left:50%;top:60px;transform:translateX(-50%);
    padding:6px 10px;border-radius:999px;font-weight:700;letter-spacing:.3px;
    background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);
    color:var(--hudDim);z-index:9;pointer-events:none;opacity:0;transition:opacity .3s
  }
  .hint.show{opacity:1}

  .paused-banner{
    position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
    pointer-events:none;z-index:12;opacity:0;transition:opacity .25s;
  }
  .paused-banner.show{opacity:1;}
  .paused-chip{
    background:rgba(0,0,0,.45);
    border:1px solid rgba(255,255,255,0.12);
    backdrop-filter:blur(6px);
    padding:12px 24px;
    border-radius:999px;
    font-weight:700;
    letter-spacing:.32rem;
    text-transform:uppercase;
    color:#fff;
  }

  /* chevron toggle */
  .hud-toggle{
    pointer-events:auto;
    width:30px;height:30px;
    border-radius:999px;
    background:rgba(0,0,0,.4);
    border:1px solid rgba(255,255,255,.1);
    display:flex;align-items:center;justify-content:center;
    cursor:pointer;
  }
  .hud-toggle svg{width:16px;height:16px;fill:none;stroke:#fff;stroke-width:1.5;}
  .hud-collapsed .hud{transform:translateY(-60px);opacity:0;pointer-events:none;}
</style>
</head>
<body>
  <div class="stage">
    <canvas id="pond"></canvas>

    <!-- chevron to collapse/expand UI -->
    <div class="hud-toggle" id="hudToggle" style="position:absolute;top:10px;left:10px;z-index:20;">
      <svg viewBox="0 0 24 24">
        <path d="M6 9l6 6 6-6" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </div>

    <div class="hud" id="hud">
      <div class="hud-left"></div>
      <div class="hud-center">
        <div class="ctl" id="pauseBtn">PAUSE</div>
        <div class="ctl" id="addBtn">ADD KOI</div>
        <div class="ctl" id="remBtn">REMOVE KOI</div>
        <div class="ctl" id="clearFood">CLEAR FOOD</div>
        <div class="ctl" id="scatterBtn">SCATTER</div>
      </div>
      <div class="hud-right">Koi Pond — by Opulent Hardware</div>
    </div>

    <div class="hint" id="hint">Tap to drop food — koi will gather, then scatter.</div>

    <div class="paused-banner" id="pausedBanner">
      <div class="paused-chip">PAUSED</div>
    </div>
  </div>

<script>
(()=> {
  // basic setup
  window.addEventListener('contextmenu', e => e.preventDefault());
  const canvas=document.getElementById('pond');
  const ctx=canvas.getContext('2d',{alpha:false});
  const pauseBtn=document.getElementById('pauseBtn');
  const addBtn=document.getElementById('addBtn');
  const remBtn=document.getElementById('remBtn');
  const clearFoodBtn=document.getElementById('clearFood');
  const scatterBtn=document.getElementById('scatterBtn');
  const hint=document.getElementById('hint');
  const pausedBanner=document.getElementById('pausedBanner');
  const hudToggle=document.getElementById('hudToggle');

  // cap DPR to keep it smooth
  let DPR = 1;
  function fit(){
    const w=canvas.clientWidth,h=canvas.clientHeight;
    canvas.width=Math.round(w*DPR);
    canvas.height=Math.round(h*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  new ResizeObserver(fit).observe(canvas); fit();

  // state
  const S={paused:false,koi:[],foods:[],t:0, causticT:0};
  const CAUSTIC_POINTS = Array.from({length:20},()=>({x:Math.random(),y:Math.random(),r:0.05+Math.random()*0.12, s:0.02+Math.random()*0.06}));

  const P={
    minKoi:8,maxKoi:24,
    speed:{min:38,max:88}, maxForce:120,
    view:130, separation:34,
    sepWeight:1.6, aliWeight:0.7, cohWeight:0.7,
    foodWeight:1.4, edgeWeight:1.0, wanderWeight:0.24,
    foodTTL:18, foodRadius:22, foodOrbit:46,
    edgeInset:28, trailLen:9, trailAlpha:0.08,
    scatterMin:1.8, scatterMax:2.6, scatterImpulse:160
  };

  const PATTERNS = [
    { name:'Kohaku',  base:'#fffdf7', patches:[{c:'#ff3b30', n:[2,4]}] },
    { name:'Sanke',   base:'#fffdf7', patches:[{c:'#ff3b30', n:[1,3]}, {c:'#111111', n:[1,2]}] },
    { name:'Showa',   base:'#111111', patches:[{c:'#fffdf7', n:[2,3]}, {c:'#ff3b30', n:[1,3]}] },
    { name:'Ogon',    base:'#ffd55a', patches:[] },
    { name:'Asagi',   base:'#86a7c8', patches:[{c:'#ff8b55', n:[2,3]}] },
  ];

  const rand=(a,b)=>a+Math.random()*(b-a);
  const choice=arr=>arr[Math.floor(Math.random()*arr.length)];
  function hud(){pauseBtn.textContent=S.paused?"RESUME":"PAUSE";pausedBanner.classList.toggle('show',S.paused);}

  function glowFromBase(b){
    if (b==='#fffdf7') return '#ffb020';
    if (b==='#111111') return '#ff3b30';
    if (b==='#ffd55a') return '#ffd55a';
    if (b==='#86a7c8') return '#36a8ff';
    return '#00ff4c';
  }

  function buildPatches(p){
    const blobs=[];
    for(const layer of p.patches){
      const c=Math.floor(rand(layer.n[0],layer.n[1]+1));
      for(let i=0;i<c;i++){
        blobs.push({
          c:layer.c,
          t:rand(-0.2,0.65),
          rx:rand(0.12,0.3),
          ry:rand(0.12,0.3),
          rot:rand(-0.7,0.7),
          a:rand(0.65,0.95)
        });
      }
    }
    return blobs;
  }

  function pickRoamTarget(k){
    const w=canvas.clientWidth,h=canvas.clientHeight;
    k.roamTarget = { x: rand(40, w-40), y: rand(40, h-40) };
    k.roamTimer = rand(3, 7);
  }

  function spawnKoi(n=1){
    const w=canvas.clientWidth,h=canvas.clientHeight;
    for(let i=0;i<n;i++){
      const x=rand(80,w-80), y=rand(80,h-80), ang=rand(0,Math.PI*2), sp=rand(P.speed.min,P.speed.max);
      const patt = choice(PATTERNS);
      const koi = {
        x,y,
        vx:Math.cos(ang)*sp*0.25, vy:Math.sin(ang)*sp*0.25,
        pattern:patt, glow: glowFromBase(patt.base),
        bias:rand(-0.22,0.22), appetite:rand(0.7,1.35),
        social:rand(0.6,1.25), personalSpace:rand(0.9,1.3),
        wanderPhase:rand(0,100), tailT:Math.random()*Math.PI*2,
        trail:[], scatterT:0, scatterDir:{x:0,y:0},
        blobs: buildPatches(patt),
        roamTarget:{x:rand(40,w-40), y:rand(40,h-40)},
        roamTimer:rand(3,7)
      };
      S.koi.push(koi);
    }
  }
  function removeKoi(n=1){S.koi.splice(0,Math.min(n,S.koi.length));}
  function dropFood(x,y){S.foods.push({x,y,ttl:P.foodTTL});}

  function triggerScatter(){
    for(const k of S.koi){
      k.scatterT=rand(P.scatterMin,P.scatterMax);
      const ang=rand(0,Math.PI*2);
      k.scatterDir={x:Math.cos(ang),y:Math.sin(ang)};
      k.vx+=k.scatterDir.x*P.scatterImpulse*0.5;
      k.vy+=k.scatterDir.y*P.scatterImpulse*0.5;
    }
  }

  // UI bindings
  pauseBtn.addEventListener('click',e=>{
    e.preventDefault();
    S.paused=!S.paused;
    hud();
  });
  addBtn.addEventListener('click',e=>{
    e.preventDefault();
    if(S.koi.length<P.maxKoi)spawnKoi(1);
  });
  remBtn.addEventListener('click',e=>{
    e.preventDefault();
    removeKoi(1);
  });
  clearFoodBtn.addEventListener('click',e=>{
    e.preventDefault();
    S.foods.length=0;
  });
  scatterBtn.addEventListener('click',e=>{
    e.preventDefault();
    triggerScatter();
  });

  canvas.addEventListener('pointerdown',e=>{
    if (S.paused) return;
    e.preventDefault();
    const r=canvas.getBoundingClientRect();
    dropFood(e.clientX-r.left, e.clientY-r.top);
  });

  hudToggle.addEventListener('click',e=>{
    e.preventDefault();
    document.body.classList.toggle('hud-collapsed');
  });

  // update loop
  function updateKoi(dt){
    const w=canvas.clientWidth,h=canvas.clientHeight;

    // food decay
    for(let i=S.foods.length-1;i>=0;i--){
      S.foods[i].ttl-=dt;
      if(S.foods[i].ttl<=0) S.foods.splice(i,1);
    }

    const noFood = S.foods.length===0;
    const aliW = P.aliWeight * (noFood?0.25:1);
    const cohW = P.cohWeight * (noFood?0.25:1);
    const sepW = P.sepWeight * (noFood?1.25:1);
    const wanderW = P.wanderWeight * (noFood?1.8:1);
    let someoneAte=false;

    for(let i=0;i<S.koi.length;i++){
      const k=S.koi[i];
      if(k.scatterT>0) k.scatterT=Math.max(0,k.scatterT-dt);

      let steerX=0, steerY=0;
      let aliX=0, aliY=0, aliN=0, cohX=0, cohY=0, cohN=0, sepX=0, sepY=0;
      const view=P.view, sepR=P.separation*k.personalSpace;

      const considerNeighbors = k.scatterT<=0.2;
      if(considerNeighbors){
        for(let j=0;j<S.koi.length;j++){
          if(i===j) continue;
          const o=S.koi[j], dx=o.x-k.x, dy=o.y-k.y, d2=dx*dx+dy*dy;
          if(d2>view*view) continue;
          const d=Math.sqrt(d2);
          aliX+=o.vx; aliY+=o.vy; aliN++;
          cohX+=o.x;  cohY+=o.y;  cohN++;
          if(d<sepR){
            const factor=(sepR-d)/sepR, inv=1/Math.max(1e-3,d);
            sepX-=dx*inv*(1+3*factor);
            sepY-=dy*inv*(1+3*factor);
          }
        }
      }

      const limit=(x,y,max)=>{
        const m=Math.hypot(x,y);
        if(m>max){const s=max/m; return [x*s,y*s];}
        return [x,y];
      };
      const setMag=(x,y,mag)=>{
        const m=Math.hypot(x,y);
        if(m<1e-5) return [0,0];
        const s=mag/m; return [x*s,y*s];
      };

      if(aliN>0){
        aliX/=aliN; aliY/=aliN;
        [aliX,aliY]=setMag(aliX,aliY,(P.speed.min+P.speed.max)*0.5);
        aliX-=k.vx; aliY-=k.vy;
        [aliX,aliY]=limit(aliX,aliY,P.maxForce*0.9);
        steerX+=aliX*aliW*k.social; steerY+=aliY*aliW*k.social;
      }
      if(cohN>0){
        cohX/=cohN; cohY/=cohN;
        cohX-=k.x; cohY-=k.y;
        [cohX,cohY]=setMag(cohX,cohY,50);
        [cohX,cohY]=limit(cohX,cohY,P.maxForce*0.6);
        steerX+=cohX*cohW*k.social; steerY+=cohY*cohW*k.social;
      }

      [sepX,sepY]=limit(sepX,sepY,P.maxForce);
      steerX+=sepX*sepW; steerY+=sepY*sepW;

      // food-seeking
      if(!noFood && k.scatterT<=0){
        let best=null,bestD2=Infinity;
        for(const f of S.foods){
          const dx=f.x-k.x, dy=f.y-k.y, dd=dx*dx+dy*dy;
          if(dd<bestD2){best=f; bestD2=dd;}
        }
        if(best){
          let fx=best.x-k.x, fy=best.y-k.y;
          const dist=Math.hypot(fx,fy);
          let ang=Math.atan2(fy,fx)+k.bias;
          fx=Math.cos(ang); fy=Math.sin(ang);
          if(dist<P.foodOrbit){
            const tx=-fy,ty=fx;
            fx=fx*0.4+tx*0.9;
            fy=fy*0.4+ty*0.9;
          }
          [fx,fy]=setMag(fx,fy,90);
          [fx,fy]=limit(fx,fy,P.maxForce);
          const appetite=P.foodWeight*k.appetite;
          steerX+=fx*appetite; steerY+=fy*appetite;
          if(dist < P.foodRadius*0.75){best.ttl=0; someoneAte=true;}
        }
      }

      // roam whole frame when no food
      if(noFood && k.scatterT<=0){
        k.roamTimer -= dt;
        const dx = k.roamTarget.x - k.x;
        const dy = k.roamTarget.y - k.y;
        const dist = Math.hypot(dx,dy);
        if(dist > 12){
          let rx = dx / Math.max(dist,1e-3) * 70;
          let ry = dy / Math.max(dist,1e-3) * 70;
          const mag = Math.hypot(rx, ry);
          const maxSteer = P.maxForce * 0.65;
          if(mag > maxSteer){
            const s = maxSteer / mag;
            rx *= s; ry *= s;
          }
          steerX += rx;
          steerY += ry;
        }
        if(dist < 14 || k.roamTimer <= 0){
          pickRoamTarget(k);
        }
      }

      // edge avoidance
      const inset=P.edgeInset;
      if(k.x<inset){steerX+=(inset-k.x)*P.edgeWeight;}
      if(k.x>w-inset){steerX-=(k.x-(w-inset))*P.edgeWeight;}
      if(k.y<inset){steerY+=(inset-k.y)*P.edgeWeight;}
      if(k.y>h-inset){steerY-=(k.y-(h-inset))*P.edgeWeight;}

      // unbiased 2D wander
      const wa = S.t*0.55 + k.wanderPhase;
      const wb = S.t*0.83 + k.wanderPhase*0.4;
      steerX += Math.cos(wa) * P.wanderWeight * (noFood?36:24);
      steerY += Math.sin(wb) * P.wanderWeight * (noFood?36:24);

      // scatter impulse
      if(k.scatterT>0){
        let sx=k.scatterDir.x, sy=k.scatterDir.y;
        [sx,sy]=setMag(sx,sy, P.scatterImpulse);
        const [lx,ly]=limit(sx,sy,P.maxForce*1.5);
        steerX+=lx; steerY+=ly;
      } else if(noFood) {
        // little random wiggle
        steerX+=rand(-12,12);
        steerY+=rand(-12,12);
      }

      // integrate
      k.vx+=steerX*dt; k.vy+=steerY*dt;
      const sp=Math.hypot(k.vx,k.vy), maxSp=P.speed.max, minSp=P.speed.min*0.7;
      if(sp>maxSp){const s=maxSp/sp; k.vx*=s; k.vy*=s;}
      if(sp<minSp && sp>1e-4){const s=minSp/sp; k.vx*=s; k.vy*=s;}
      k.x+=k.vx*dt; k.y+=k.vy*dt;

      // tail + trail
      k.tailT+=dt*(4+sp*0.02);
      if(!k.trail.length || Math.hypot(k.x-k.trail[0].x,k.y-k.trail[0].y)>5){
        k.trail.unshift({x:k.x,y:k.y});
        if(k.trail.length>P.trailLen)k.trail.pop();
      }
    }

    if(someoneAte){ triggerScatter(); }
  }

  function draw(){
    const w=canvas.clientWidth,h=canvas.clientHeight;
    ctx.fillStyle="#000"; ctx.fillRect(0,0,w,h);

    const vign = ctx.createRadialGradient(w/2,h/2,0,w/2,h/2,Math.max(w,h)*0.7);
    vign.addColorStop(0,"rgba(0,0,0,0)");
    vign.addColorStop(1,"rgba(0,0,0,0.55)");
    ctx.fillStyle=vign; ctx.fillRect(0,0,w,h);

    drawCaustics(w,h);

    const bgGlow=getComputedStyle(document.documentElement).getPropertyValue('--gridGlow').trim()||'#00ff4c';

    // food
    ctx.save(); ctx.globalCompositeOperation='lighter';
    for(const f of S.foods){
      const a=Math.max(0,Math.min(1,f.ttl/P.foodTTL));
      const r=9+6*(1-a)+1.5*Math.sin(S.t*3+f.x*0.01);
      ctx.shadowBlur=10; ctx.shadowColor=bgGlow;
      ctx.fillStyle=hex(bgGlow,0.35+0.45*(1-a));
      circle(f.x,f.y,r);
    }
    ctx.restore();

    // trails
    ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.lineWidth=1.7;
    for(const k of S.koi){
      ctx.shadowBlur=8; ctx.shadowColor=k.glow; ctx.strokeStyle=hex(k.glow,P.trailAlpha);
      ctx.beginPath();
      for(let i=0;i<k.trail.length;i++){
        const p=k.trail[i];
        if(i===0)ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
      }
      ctx.stroke();
    }
    ctx.restore();

    // koi
    ctx.save(); ctx.globalCompositeOperation='lighter';
    for(const k of S.koi){
      const ang=Math.atan2(k.vy,k.vx), sp=Math.hypot(k.vx,k.vy);
      const wob=Math.sin(k.tailT)*0.6 + Math.sin(k.tailT*0.33)*0.35;
      const body=22 + Math.min(16, sp*0.04), tail=body*1.1;
      ctx.shadowBlur=14; ctx.shadowColor=k.glow;
      drawKoiIndie(k.x,k.y,ang,body,tail,wob,k.pattern.base,k.blobs,k.glow);
    }
    ctx.restore();

    if(S.paused){
      ctx.fillStyle="rgba(0,0,0,0.24)";
      ctx.fillRect(0,0,w,h);
    }
  }

  function drawCaustics(w,h){
    S.causticT += 0.0018;
    ctx.save(); ctx.globalCompositeOperation = 'screen';
    for(const p of CAUSTIC_POINTS){
      const x = (p.x + Math.sin(S.causticT*p.s)*0.05 + 1) % 1;
      const y = (p.y + Math.cos(S.causticT*(p.s+0.03))*0.04 + 1) % 1;
      const cx = x*w, cy = y*h, r = Math.max(w,h) * p.r;
      const g = ctx.createRadialGradient(cx,cy,0,cx,cy,r);
      g.addColorStop(0, 'rgba(255,255,255,0.02)');
      g.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  function drawKoiIndie(x,y,ang,body,tailLen,wobble,baseColor,patches,glow){
    ctx.save(); ctx.translate(x,y); ctx.rotate(ang);

    const path = new Path2D();
    path.moveTo(-body*0.58, -body*0.36);
    path.quadraticCurveTo(body*0.12, -body*0.55, body*0.82, 0);
    path.quadraticCurveTo(body*0.12,  body*0.55, -body*0.58, body*0.36);
    path.closePath();

    const grad=ctx.createLinearGradient(-body*0.6,-body*0.6,body*0.9,body*0.6);
    grad.addColorStop(0, hex(baseColor, 0.95));
    grad.addColorStop(0.45, hex('#ffffff', 0.12));
    grad.addColorStop(1, hex(baseColor, 1.0));
    ctx.fillStyle = grad; ctx.fill(path);

    ctx.save(); ctx.globalCompositeOperation='multiply';
    ctx.strokeStyle = 'rgba(0,0,0,0.35)'; ctx.lineWidth = Math.max(1.2, body*0.06); ctx.stroke(path);
    ctx.restore();

    // patches
    ctx.save(); ctx.clip(path); ctx.globalCompositeOperation='source-over';
    for(const b of patches){
      const cx = lerp(-body*0.2, body*0.55, (b.t+0.2)/0.75);
      const cy = Math.sin(b.t*8.3)*body*0.05;
      ctx.save(); ctx.translate(cx, cy); ctx.rotate(b.rot); ctx.fillStyle = hex(b.c, b.a);
      ellipse(0,0, body*b.rx, body*b.ry); ctx.restore();
    }
    ctx.restore();

    // highlight
    ctx.save(); ctx.globalCompositeOperation='overlay'; ctx.fillStyle=hex('#ffffff',0.05);
    ellipse(body*0.58, 0, body*0.25, body*0.20); ctx.restore();

    // dorsal/pectoral fins
    ctx.save();
    const finFill = hex(glow, 0.20); ctx.fillStyle = finFill;
    ctx.beginPath();
    ctx.moveTo(-body*0.08, -body*0.42);
    ctx.quadraticCurveTo(body*0.10, -body*0.58, body*0.28, -body*0.22);
    ctx.quadraticCurveTo(body*0.08, -body*0.20, -body*0.08, -body*0.42);
    ctx.closePath(); ctx.fill();

    drawPectoral(-body*0.05,  body*0.22,  body, +1, wobble, glow);
    drawPectoral(-body*0.05, -body*0.22,  body, -1, wobble, glow);
    ctx.restore();

    // tail
    ctx.save(); ctx.translate(-body*0.60, 0); ctx.rotate(wobble*0.22);
    ctx.fillStyle = hex(glow, 0.35);
    finLobe(0,0, -tailLen*0.9, -body*0.14, -tailLen, -body*0.02);
    finLobe(0,0, -tailLen*0.9,  body*0.14, -tailLen,  body*0.02);
    ribbon(-tailLen*0.75, -body*0.02, -tailLen*1.2, -body*0.20, wobble);
    ribbon(-tailLen*0.75,  body*0.02, -tailLen*1.2,  body*0.20, -wobble);
    ctx.restore();

    // eye
    ctx.fillStyle=hex('#000000',0.35); circle(body*0.52, -body*0.05, Math.max(1.4, body*0.06));

    ctx.restore();
  }

  function drawPectoral(x,y,body,side,wob,glow){
    ctx.save(); ctx.translate(x,y); ctx.rotate(wob*0.12*side);
    ctx.fillStyle = hex(glow, 0.22);
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.quadraticCurveTo(body*0.16*side,  body*0.08,  body*0.22*side,  0);
    ctx.quadraticCurveTo(body*0.16*side, -body*0.08,  0,0);
    ctx.closePath(); ctx.fill(); ctx.restore();
  }

  function ellipse(x,y,rx,ry){ctx.beginPath(); ctx.ellipse(x,y,Math.abs(rx),Math.abs(ry),0,0,Math.PI*2); ctx.fill();}
  function finLobe(x0,y0, cx,cy, x1,y1){ctx.beginPath(); ctx.moveTo(x0,y0); ctx.quadraticCurveTo(cx,cy, x1,y1); ctx.quadraticCurveTo((x0+x1)*0.5, (y0+y1)*0.5, x0,y0); ctx.closePath(); ctx.fill();}
  function ribbon(x0,y0,x1,y1,wob){ctx.beginPath(); ctx.moveTo(x0,y0); const midx=(x0+x1)/2, midy=(y0+y1)/2 + Math.sin(wob*1.8)*((y1-y0)*0.4); ctx.quadraticCurveTo(midx, midy, x1,y1); ctx.quadraticCurveTo(midx+8, midy+8, x0,y0); ctx.closePath(); ctx.fill();}
  function circle(x,y,r){ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.closePath();ctx.fill();}
  function hex(hexstr,a=1){const h=hexstr.replace('#','');const n=parseInt(h.length===3?h.split('').map(c=>c+c).join(''):h,16); const r=(n>>16)&255,g=(n>>8)&255,b=n&255;return `rgba(${r},${g},${b},${a})`; }
  function lerp(a,b,t){return a+(b-a)*t;}

  // loop
  let last=performance.now();
  function step(now){
    const dt=Math.min(0.05,(now-last)/1000); last=now;
    if(!S.paused){S.t+=dt; updateKoi(dt);}
    draw();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  // boot
  function resetHint(){ setTimeout(()=>hint.classList.add('show'),300); setTimeout(()=>hint.classList.remove('show'),4000); }
  spawnKoi(P.minKoi); resetHint(); hud();

})();
</script>
</body>
</html>
